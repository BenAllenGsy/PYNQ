

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>IO Processors: Writing Your Own Software &mdash; Python productivity for Zynq (Pynq) v1.0</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Python productivity for Zynq (Pynq) v1.0" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Python productivity for Zynq (Pynq)
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="1_getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_pynq.html">PYNQ Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_jupyter_notebook.html">Jupyter Notebook Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_programming_python.html">Cortex-A9 programming in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_programming_onboard.html">Programming PYNQ-Z1&#8217;s onboard peripherals</a></li>
<li class="toctree-l1"><a class="reference internal" href="6_overlays.html">Introduction to Overlays</a></li>
<li class="toctree-l1"><a class="reference internal" href="7_iop_architecture.html">IO Processor Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="8_iop_code.html">IO Processors: Writing Your Own Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="9a_base_overlay_iop.html">Using Peripherals with the Base overlay</a></li>
<li class="toctree-l1"><a class="reference internal" href="9b_base_overlay_video.html">Video using the Base Overlay</a></li>
<li class="toctree-l1"><a class="reference internal" href="9c_base_overlay_audio.html">Audio using the Base Overlay</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_creating_overlays.html">Creating Overlays</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_python_package.html"><code class="docutils literal"><span class="pre">pynq</span></code> Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_verification.html">Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html"><code class="docutils literal"><span class="pre">pynq</span></code> package reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="14_faqs.html">Frequently Asked Questions (FAQs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="15_glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="16_references.html">Useful Reference Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="17_appendix.html">Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="18_changelog.html">Documentation Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Python productivity for Zynq (Pynq)</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>IO Processors: Writing Your Own Software</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/9_iop_code.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput,
div.nbinput > div,
div.nbinput div[class^=highlight],
div.nbinput div[class^=highlight] pre,
div.nboutput,
div.nboutput > div,
div.nboutput div[class^=highlight],
div.nboutput div[class^=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* input/output containers */
div.nbinput,
div.nboutput {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
}

/* input container */
div.nbinput {
    padding-top: 5px;
}

/* last container */
div.nblast {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput > :first-child pre {
    color: navy;
}

/* output prompt */
div.nboutput > :first-child pre {
    color: darkred;
}

/* all prompts */
div.nbinput > :first-child[class^=highlight],
div.nboutput > :first-child[class^=highlight],
div.nboutput > :first-child {
    min-width: 11ex;
    padding-top: 0.4em;
    padding-right: 0.4em;
    text-align: right;
    flex: 0;
}

/* input/output area */
div.nbinput > :nth-child(2)[class^=highlight],
div.nboutput > :nth-child(2),
div.nboutput > :nth-child(2)[class^=highlight] {
    padding: 0.4em;
    -webkit-flex: 1;
    flex: 1;
}

/* input area */
div.nbinput > :nth-child(2)[class^=highlight] {
    border: 1px solid #cfcfcf;
    border-radius: 2px;
    background: #f7f7f7;
}

/* override MathJax center alignment in output cells */
div.nboutput div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.pngmath center alignment in output cells */
div.nboutput div.math p {
    text-align: left;
}

/* standard error */
div.nboutput  > :nth-child(2).stderr {
    background: #fdd;
}

/* ANSI colors */
.ansiblack { color: black; }
.ansired { color: darkred; }
.ansigreen { color: darkgreen; }
.ansiyellow { color: #c4a000; }
.ansiblue { color: darkblue; }
.ansipurple { color: darkviolet; }
.ansicyan { color: steelblue; }
/* See https://github.com/jupyter/nbconvert/issues/174 */
.ansigray { color: gray; }  /* nbconvert CSS */
.ansigrey { color: gray; }  /* nbconvert HTML output */

.ansibgblack { background-color: black; }
.ansibgred { background-color: red; }
.ansibggreen { background-color: green; }
.ansibgyellow { background-color: yellow; }
.ansibgblue { background-color: blue; }
.ansibgpurple { background-color: magenta; }
.ansibgcyan { background-color: cyan; }
.ansibggray { background-color: gray; }

.ansibold { font-weight: bold; }
</style>
<div class="section" id="io-processors-writing-your-own-software">
<h1>IO Processors: Writing Your Own Software<a class="headerlink" href="#io-processors-writing-your-own-software" title="Permalink to this headline">¶</a></h1>
<p>There are a number of steps required before you can start writing your own software for an IOP (IO Processor). This document will describe the IOP architecture, and how to set up and build the required software projects to allow you to write your own application for the MicroBlaze inside an IOP. Xilinx SDK projects can be created manually using the SDK GUI, or software can be built using a Makefile flow.</p>
<div class="section" id="io-processors">
<h2>IO Processors<a class="headerlink" href="#io-processors" title="Permalink to this headline">¶</a></h2>
<p>As seen previously, an IOP can be used as a flexible controller for different types of external peripherals. The ARM Cortex-A9 is an application processor, which runs Pynq and Jupyter notebook on a Linux OS. This scenario is not well suited to real-time applications, which is a common requirement for an embedded systems.  In the base overlay there are three IOPs. As well as acting as a flexible controller, an IOP can be used as dedicated real-time controller.</p>
<p>IOPs can also be used standalone to offload some processing from the main processor. However, note that the MicroBlaze processor inside an IOP in the base overlay is running at 100 MHz, compared to the Dual-Core ARM Cortex-A9 running at 650 MHz. The clock speed, and different processor architectures and features should be taken into account when offloading pure application code. e.g. Vector processing on the ARM Cortex-A9 Neon processing unit will be much more efficient than running on the MicroBlaze. The MicroBlaze is most appropriate for low-level, background, or real-time applications.</p>
<p>There are two types of IOP, a Pmod IOP and an Arduino IOP.</p>
<p>Previous sections showed the similarities between the Pmod IOP and Arduino IOP. Each IOP contains a <a class="reference external" href="https://en.wikipedia.org/wiki/MicroBlaze">Xilinx MicroBlaze processor</a>, a Debug module, and one or more of the following functional units and interface peripherals:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://www.xilinx.com/support/documentation/ip_documentation/axi_timer/v2_0/pg079-axi-timer.pdf">AXI Timer</a></li>
<li><a class="reference external" href="http://www.xilinx.com/support/documentation/ip_documentation/axi_iic/v2_0/pg090-axi-iic.pdf">AXI IIC</a></li>
<li><a class="reference external" href="http://www.xilinx.com/support/documentation/ip_documentation/axi_quad_spi/v3_2/pg153-axi-quad-spi.pdf">AXI SPI</a></li>
<li><a class="reference external" href="http://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">AXI GPIO</a></li>
</ul>
</div></blockquote>
<p>The Arduino also includes a UART, and XADC.</p>
<p>The interface peripherals are connected to a Configurable Switch. The switch is different for the Pmod and the Arduino IOPs. The Pmod configurable switch connects to a Pmod port, and the Arduino configurable switch connects to an Arduino interface connector.</p>
<p>Pmod IOP:</p>
<img alt="_images/pmod_iop.jpg" class="align-center" src="_images/pmod_iop.jpg" />
<p>The IOP&#8217;s configurable switch can be used to route signals between the physical interface, and the available internal peripherals in the IOP sub-system.</p>
</div>
<div class="section" id="software-requirements">
<h2>Software requirements<a class="headerlink" href="#software-requirements" title="Permalink to this headline">¶</a></h2>
<p>A MicroBlaze cross-compiler is required to build software for the MicroBlaze inside an IOP.  Xilinx SDK contains the MicroBlaze cross-compiler and was used to build all Pmod device drivers released with Pynq and is available for free.  It should be noted that Pynq ships with precompiled IOP executables to support various peripherals (see <a class="reference external" href="modules.html">Pynq Modules</a>), but that full source code is available from the project GitHub. Xilinx software is only needed if you intend to build your own IOP applications/peripheral drivers. A free, fully functional, version of the Xilinx tools is available for Pynq if required (see the free <a class="reference external" href="https://www.xilinx.com/products/design-tools/vivado/vivado-webpack.html">Xilinx Vivado WebPack</a> for more details).</p>
<p>The current Pynq release is built using Vivado and SDK 2016.1. it is recommended to use the same version to rebuild existing Vivado and SDK projects. If you only intend to build software, you will only need to install SDK. The full Vivado and SDK installation is only required to design new overlays.</p>
<p><a class="reference external" href="http://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools/2016-1.html">Download Xilinx Vivado and SDK 2016.1</a></p>
<p>You can use the Vivado HLx Web Install Client and select SDK and/or Vivado during the installation.</p>
<p>Pynq also support building of bitstreams from SDSoC. SDSoC is currently a separate download and installation from the main Vivado/SDK software.</p>
</div>
<div class="section" id="compiling-projects">
<h2>Compiling projects<a class="headerlink" href="#compiling-projects" title="Permalink to this headline">¶</a></h2>
<p>Software executables run on the MicroBlaze inside the IOP. Code for the MicroBlaze can be written in C or C++ and compiled using the <a class="reference external" href="http://www.xilinx.com/products/design-tools/embedded-software/sdk.html">Xilinx SDK (Software Development Kit)</a>.</p>
<p>You can pull or clone the Pynq GitHub repository, and all the driver source and project files can be found in <code class="docutils literal"><span class="pre">&lt;GitHub</span> <span class="pre">Repository&gt;\Pynq-Z1\sdk</span></code>,  (Where <code class="docutils literal"><span class="pre">&lt;GitHub</span> <span class="pre">Repository&gt;</span></code> is the location of the PYNQ repository).</p>
<p>These projects are considered SDK <em>Application</em> projects and contain the top level application. Each SDK project requires a BSP project (Board Support Package), and a hardware platform project. See below for more details. Software libraries are included in a Board Support Package (BSP) project, and the BSP is linked to from the application project.</p>
<p>All <em>Application</em> projects can be compiled from the command line using Makefiles, or imported into the SDK GUI.</p>
<p>You can also use existing projects as a starting point to create your own project.</p>
<div class="section" id="hdf-file">
<h3>HDF file<a class="headerlink" href="#hdf-file" title="Permalink to this headline">¶</a></h3>
<p>Before an Application project and BSP can be created or compiled in SDK, a <em>Hardware Platform</em>  project is required. A Hardware Platform defines the peripherals in the IOP subsystem, and the memory map of the system, and is used by the BSP to build software libraries to support the underlying hardware.</p>
<p>A Hardware Description File (.hdf), created by Vivado, is used to create the <em>Hardware Platfrom</em>  project in SDK.</p>
<p>A precompiled .hdf file is provided, so it is not necessary to run Vivado to generate a .hdf file:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">&lt;GitHub</span> <span class="pre">Repository&gt;/Pynq-Z1/sdk/</span></code></div></blockquote>
</div>
<div class="section" id="board-support-package">
<h3>Board Support Package<a class="headerlink" href="#board-support-package" title="Permalink to this headline">¶</a></h3>
<p>The BSP (Board Support Package) contains software libraries and drivers to support the underlying peripherals in the system.</p>
<p>A BSP must be linked to a Hardware Platform, as this is where the peripherals in the system are defined. An Application Project is then linked to a BSP, and can use the libraries available in the BSP.</p>
</div>
<div class="section" id="building-the-projects">
<h3>Building the projects<a class="headerlink" href="#building-the-projects" title="Permalink to this headline">¶</a></h3>
<p>A Makefile to automatically create and build the Hardware Platform and the BSP can be found in the same location as the .hdf file.</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">&lt;GitHub</span> <span class="pre">Repository&gt;/Pynq-Z1/sdk/makefile</span></code></div></blockquote>
<p>Application projects for peripherals that ship with Pynq (e.g. Pmods and Grove peripherals) can also be found in the same location. Each project is contained in a separate folder.</p>
<p>The Makefile uses the .hdf file to create the Hardware Platform. The BSP can then be created. The application projects will also be compiled automatically as part of this process.</p>
<p>The Makefile requires SDK to be installed, and can be run from Windows, or Linux.</p>
<p>To run <code class="docutils literal"><span class="pre">make</span></code> from Windows, open SDK, and choose a temporary workspace (make sure this path is external to the downloaded GitHub repository). From the <em>Xilinx Tools</em> menu, select <em>Launch Shell</em></p>
<a class="reference internal image-reference" href="_images/sdk_launch_shell.jpg"><img alt="_images/sdk_launch_shell.jpg" class="align-center" src="_images/sdk_launch_shell.jpg" style="width: 603.75px; height: 255.75px;" /></a>
<p>In Linux, open a terminal, and source the SDK tools.</p>
<p>From either the Windows Shell, or the Linux terminal, navigate to the sdk folder in your local copy of the GitHub repository:</p>
<blockquote>
<div>cd to <code class="docutils literal"><span class="pre">&lt;GitHub</span> <span class="pre">Repository&gt;/Pynq-Z1/sdk</span></code> and run <code class="docutils literal"><span class="pre">make</span></code></div></blockquote>
<a class="reference internal image-reference" href="_images/sdk_make.JPG"><img alt="_images/sdk_make.JPG" class="align-center" src="_images/sdk_make.JPG" style="width: 506.25px; height: 415.5px;" /></a>
<a class="reference internal image-reference" href="_images/sdk_make_result.JPG"><img alt="_images/sdk_make_result.JPG" class="align-center" src="_images/sdk_make_result.JPG" style="width: 506.25px; height: 435.75px;" /></a>
<p>This will create the Hardware Platform Project (<em>hw_def</em>), and the Board Support Package (<em>bsp</em>), and then link and build all the application projects.</p>
<p>If you examine the Makefile, you can see how the <em>MBBINS</em> variable at the top of the makefile is used to compile the application projects. If you want to add your own custom project to the build process, you need to add the project name to the <em>MBBINS</em> variable, and save the project in the same location as the other application projects.</p>
<p>Individual projects can be built by navigating to the <code class="docutils literal"><span class="pre">&lt;project</span> <span class="pre">directory&gt;/Debug</span></code> and running <code class="docutils literal"><span class="pre">make</span></code>.</p>
</div>
<div class="section" id="binary-files">
<h3>Binary files<a class="headerlink" href="#binary-files" title="Permalink to this headline">¶</a></h3>
<p>Compiling code produces an executable file (.elf) which needs to be converted to binary format (.bin) to be downloaded to, and run on, an IOP.</p>
<p>A .bin file can be generated from a .elf by running the following command from the SDK shell:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">mb-objcopy</span> <span class="pre">-O</span> <span class="pre">binary</span> <span class="pre">&lt;inputfile&gt;.elf</span> <span class="pre">&lt;outputfile&gt;.bin</span></code></div></blockquote>
<p>This is done automatically by the makefile for the existing application projects. The makefile will also copy all .bin files into the <code class="docutils literal"><span class="pre">&lt;GitHub</span> <span class="pre">Repository&gt;/Pynq-Z1/sdk/bin</span></code> folder.</p>
</div>
<div class="section" id="creating-your-own-application-project">
<h3>Creating your own Application project<a class="headerlink" href="#creating-your-own-application-project" title="Permalink to this headline">¶</a></h3>
<p>Using the Makefile flow, you can use an existing project as a starting point for your own project.</p>
<p>Copy and rename the project, and modify or replace the .c file in the src/ with your C code. The generated .bin file will have the same base name as your C file.</p>
<p>e.g. if your C code is my_peripheral.c, the generated .elf and .bin will be my_peripheral.elf and my_peripheral.bin.</p>
<p>We encourage the following naming convention for applications &lt;pmod|grove|arduino&gt;_&lt;peripheral&gt;</p>
<p>You will need to update references from the old project name to your new project name in <code class="docutils literal"><span class="pre">&lt;project</span> <span class="pre">directory&gt;/Debug/makefile</span></code> and <code class="docutils literal"><span class="pre">&lt;project</span> <span class="pre">directory&gt;/Debug/src/subdir.mk</span></code></p>
<p>If you want your project to build in the main Makefile, you should also append the .bin name of your project to the <em>MBBINS</em> variable at the top of the makefile.</p>
<p>If you are using the SDK GUI, you can import the Hardware Platform, BSP, and any application projects into your SDK workspace.</p>
<a class="reference internal image-reference" href="_images/sdk_import_bsp.JPG"><img alt="_images/sdk_import_bsp.JPG" class="align-center" src="_images/sdk_import_bsp.JPG" style="width: 642.0px; height: 438.75px;" /></a>
<p>The SDK GUI can be used to build and debug your code.</p>
</div>
</div>
<div class="section" id="iop-memory">
<h2>IOP Memory<a class="headerlink" href="#iop-memory" title="Permalink to this headline">¶</a></h2>
<p>The IOP instruction and data memory is implemented in a dual port Block RAM, with one port connected to the IOP, and the other to the ARM processor. This allows an executable binary file to be written from the ARM (i.e. the Pynq environment) to the IOP instruction memory. The IOP can also be reset from Pynq, allowing the IOP to start executing the new program. The IOP data memory is also used as a mailbox for communication and data exchanges between the Pynq environment and the IOP.</p>
</div>
<div class="section" id="memory-map">
<h2>Memory map<a class="headerlink" href="#memory-map" title="Permalink to this headline">¶</a></h2>
<p>The IOP memory is 64KB of shared data and instruction memory. Instruction memory for the IOP starts at address 0x0.
Pynq and the application running on the IOP can write to anywhere in the shared memory space (although care should be taken not to write to the instruction memory unintentionally as this will corrupt the running application).</p>
<p>When building the MicroBlaze project, the compiler will only ensure that the application and <em>allocated</em> stack and heap fit into the BRAM. For communication between the ARM and the MicroBlaze, a part of the shared memory space must also be reserved within the MicroBlaze address space.</p>
<p>There is no memory management in the IOP. You must ensure the application, including stack and heap, do not overflow into the defined data area. Remember that declaring a stack and heap size only allocates space to the stack and heap. No boundary is created, so if sufficient space was not allocated, the stack and heap may overflow.</p>
<p>If you need to modify the stack and heap for an application, the linker script can be found in the <code class="docutils literal"><span class="pre">&lt;project&gt;/src/</span></code> directory.</p>
<p>It is recommended to follow the convention for data communication between the two processors via MAILBOX. These MAILBOX values are defined in the header file.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="80%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Instruction and data memory start</td>
<td>0x0</td>
</tr>
<tr class="row-even"><td>Instruction and data memory size</td>
<td>0xf000</td>
</tr>
<tr class="row-odd"><td>Shared mailbox memory start</td>
<td>0xf000</td>
</tr>
<tr class="row-even"><td>Shared mailbox memory size</td>
<td>0x1000</td>
</tr>
<tr class="row-odd"><td>Shared mailbox Command Address</td>
<td>0xfffc</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The following example explains how Python could initiate a read from a peripheral connected to an IOP.</p>
<ol class="arabic simple">
<li>Python writes a read command (e.g. 0x3) to the mailbox command address (0xfffc).</li>
<li>MicroBlaze application checks the command address, and reads and decodes the command.</li>
<li>MicroBlaze performs a read from the peripheral and places the data at the mailbox base address (0xf000).</li>
<li>MicroBlaze writes 0x0 to the mailbox command address (0xfffc) to confirm transaction is complete.</li>
<li>Python checks the command address (0xfffc), and sees that the MicroBlaze has written 0x0, indicating the read is complete, and data is available.</li>
<li>Python reads the data in the mailbox base address (0xf000), completing the read.</li>
</ol>
<div class="section" id="controlling-the-pmod-iop-switch">
<h3>Controlling the Pmod IOP Switch<a class="headerlink" href="#controlling-the-pmod-iop-switch" title="Permalink to this headline">¶</a></h3>
<p>There are 8 data pins on a Pmod port, that can be connected to any of 16 internal peripheral pins (8x GPIO, 2x SPI, 4x IIC, 2x Timer).</p>
<p>Each pin can be configured by writing a 4 bit value to the corresponding place in the IOP Switch configuration register.
The following function, part of the provided pmod_io_switch_v1_0 driver (<code class="docutils literal"><span class="pre">pmod.h</span></code>) can be used to configure the switch.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">config_pmod_switch</span><span class="p">(</span><span class="kt">char</span> <span class="n">pin0</span><span class="p">,</span> <span class="kt">char</span> <span class="n">pin1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">pin2</span><span class="p">,</span> <span class="kt">char</span> <span class="n">pin3</span><span class="p">,</span> <span class="kt">char</span> <span class="n">pin4</span><span class="p">,</span> \
    <span class="kt">char</span> <span class="n">pin5</span><span class="p">,</span> <span class="kt">char</span> <span class="n">pin6</span><span class="p">,</span> <span class="kt">char</span> <span class="n">pin7</span><span class="p">);</span>
</pre></div>
</div>
<p>While each parameter is a &#8220;char&#8221; only the lower 4-bits are currently used to configure each pin.</p>
<p>Switch mappings used for IOP Switch configuration:</p>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Pin</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GPIO_0</td>
<td>0x0</td>
</tr>
<tr class="row-odd"><td>GPIO_1</td>
<td>0x1</td>
</tr>
<tr class="row-even"><td>GPIO_2</td>
<td>0x2</td>
</tr>
<tr class="row-odd"><td>GPIO_3</td>
<td>0x3</td>
</tr>
<tr class="row-even"><td>GPIO_4</td>
<td>0x4</td>
</tr>
<tr class="row-odd"><td>GPIO_5</td>
<td>0x5</td>
</tr>
<tr class="row-even"><td>GPIO_6</td>
<td>0x6</td>
</tr>
<tr class="row-odd"><td>GPIO_7</td>
<td>0x7</td>
</tr>
<tr class="row-even"><td>SCL</td>
<td>0x8</td>
</tr>
<tr class="row-odd"><td>SDA</td>
<td>0x9</td>
</tr>
<tr class="row-even"><td>SPICLK</td>
<td>0xa</td>
</tr>
<tr class="row-odd"><td>MISO</td>
<td>0xb</td>
</tr>
<tr class="row-even"><td>MOSI</td>
<td>0xc</td>
</tr>
<tr class="row-odd"><td>SS</td>
<td>0xd</td>
</tr>
<tr class="row-even"><td>PWM</td>
<td>0xe</td>
</tr>
<tr class="row-odd"><td>TIMER</td>
<td>0xf</td>
</tr>
</tbody>
</table>
<p>For example, to connect the physical pins GPIO 0-7 to the internal GPIO_0 - GPIO_7:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">config_pmod_switch</span><span class="p">(</span><span class="n">GPIO_0</span><span class="p">,</span> <span class="n">GPIO_1</span><span class="p">,</span> <span class="n">GPIO_2</span><span class="p">,</span> <span class="n">GPIO_3</span><span class="p">,</span> <span class="n">GPIO_4</span><span class="p">,</span> \
    <span class="n">GPIO_5</span><span class="p">,</span> <span class="n">GPIO_6</span><span class="p">,</span> <span class="n">GPIO_7</span><span class="p">);</span>
</pre></div>
</div>
<p>From Python all the constants and addresses for the IOP can be found in:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">&lt;GitHub</span> <span class="pre">Repository&gt;/python/pynq/iop/iop_const.py</span></code></div></blockquote>
<p>Note that if two or more pins are connected to the same signal, the pins are OR&#8217;d together internally. This is not recommended and should not be done unintentionally.</p>
<p>Any application that uses the Pmod driver should also call pmod_init() at the beginning of the application.</p>
</div>
</div>
<div class="section" id="running-code-on-different-iops">
<h2>Running code on different IOPs<a class="headerlink" href="#running-code-on-different-iops" title="Permalink to this headline">¶</a></h2>
<p>The shared memory is the only connection between the ARM and the IOPs in the base overlay. The shared memory of a MicroBlaze is mapped to the ARM address space.  Some example mappings are shown below to highlight the address translation between MicroBlaze and ARM&#8217;s memory spaces.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="36%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">IOP Base Address</th>
<th class="head">MicroBlaze Address Space</th>
<th class="head">ARM Equivalent Address Space</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x4000_0000</td>
<td>0x0000_0000 - 0x0000_ffff</td>
<td>0x4000_0000 - 0x4000_ffff</td>
</tr>
<tr class="row-odd"><td>0x4200_0000</td>
<td>0x0000_0000 - 0x0000_ffff</td>
<td>0x4200_0000 - 0x4200_ffff</td>
</tr>
<tr class="row-even"><td>0x4400_0000</td>
<td>0x0000_0000 - 0x0000_ffff</td>
<td>0x4400_0000 - 0x4400_ffff</td>
</tr>
</tbody>
</table>
<p>Note that each MicroBlaze has the same range for its address space. However, the location of each IOPs address space in the ARM memory map is different for each IOP. As the address space is the same for each IOP, any binary compiled for one Pmod IOP will work on another Pmod IOP.</p>
<p>e.g. if IOP1 exists at 0x4000_0000, and IOP2 (a second instance of an IOP) exists at 0x4200_0000, the same binary can run on IOP1 by writing the binary from python to the 0x4000_0000 address space, and on IOP2 by writing to the 0x4200_0000.</p>
</div>
<div class="section" id="iop-application-example">
<h2>IOP Application Example<a class="headerlink" href="#iop-application-example" title="Permalink to this headline">¶</a></h2>
<p>Taking Pmod ALS as an example IOP driver (used to control the PMOD light sensor), first open the pmod_als.c file:</p>
<p><code class="docutils literal"><span class="pre">&lt;GitHub</span> <span class="pre">Repository&gt;/Pynq-Z1/sdk/pmod_als/src/pmod_als.c</span></code></p>
<p>Note that the <code class="docutils literal"><span class="pre">pmod.h</span></code> header file is included.</p>
<p>Some <em>COMMANDS</em> are defined by the user. These values can be chosen to be any value, but must correspond with the Python part of the driver.</p>
<p>By convention, 0x0 is reserved for no command/idle/acknowledge, and IOP commands can be any non-zero value.</p>
<p>The ALS peripheral has as SPI interface. Note the user defined function get_sample() which calls an SPI function spi_transfer() call defined in pmod.h.</p>
<p>In <code class="docutils literal"><span class="pre">main()</span></code> notice <code class="docutils literal"><span class="pre">config_pmod_switch()</span></code> is called to initialize the switch with a static configuration. This means that if you want to use this code with a different pin configuration, the C code must be modified and recompiled.</p>
<p>Next, the <code class="docutils literal"><span class="pre">while(1)</span></code> loop is entered. In this loop the IOP continually checks the <code class="docutils literal"><span class="pre">MAILBOX_CMD_ADDR</span></code> for a non-zero command. Once a command is received from Python, the command is decoded, and executed.</p>
<p>Taking the first case, reading a single value:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nl">READ_SINGLE_VALUE</span><span class="p">:</span>
    <span class="n">MAILBOX_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_sample</span><span class="p">();</span>
    <span class="n">MAILBOX_CMD_ADDR</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">get_sample()</span></code> is called and a value returned to the first position (0) of the <code class="docutils literal"><span class="pre">MAILBOX_DATA</span></code>.</p>
<p><code class="docutils literal"><span class="pre">MAILBOX_CMD_ADDR</span></code> is reset to zero to acknowledge to the ARM processor that the operation is complete and data is available in the mailbox.</p>
<div class="section" id="examine-python-code">
<h3>Examine Python Code<a class="headerlink" href="#examine-python-code" title="Permalink to this headline">¶</a></h3>
<p>With the IOP Driver written, the Python class can be built that will communicate with that IOP.</p>
<p><code class="docutils literal"><span class="pre">&lt;GitHub</span> <span class="pre">Repository&gt;/python/pynq/iop/pmod_als.py</span></code></p>
<p>First the MMIO, request_iop, iop_const, PMODA and PMODB are imported.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">pynq</span> <span class="kn">import</span> <span class="n">MMIO</span>
<span class="kn">from</span> <span class="nn">pynq.iop</span> <span class="kn">import</span> <span class="n">request_iop</span>
<span class="kn">from</span> <span class="nn">pynq.iop</span> <span class="kn">import</span> <span class="n">iop_const</span>
<span class="kn">from</span> <span class="nn">pynq.iop</span> <span class="kn">import</span> <span class="n">PMODA</span>
<span class="kn">from</span> <span class="nn">pynq.iop</span> <span class="kn">import</span> <span class="n">PMODB</span>

<span class="n">ALS_PROGRAM</span> <span class="o">=</span> <span class="s2">&quot;pmod_als.bin&quot;</span>
</pre></div>
</div>
<p>The MicroBlaze binary for the IOP is also declared. This is the application executable, and will be loaded into the IOP instruction memory.</p>
<p>The ALS class and an initialization method are defined:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Pmod_ALS</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">if_id</span><span class="p">):</span>
</pre></div>
</div>
<p>The initialization function for the module requires an IOP index. For Grove peripherals and the StickIt connector, the StickIt port number can also be used for initialization.  The <code class="docutils literal"><span class="pre">__init__</span></code> is called when a module is instantiated. e.g. from Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pynq.pmods</span> <span class="kn">import</span> <span class="n">Pmod_ALS</span>
<span class="n">als</span> <span class="o">=</span> <span class="n">Pmod_ALS</span><span class="p">(</span><span class="n">PMODB</span><span class="p">)</span>
</pre></div>
</div>
<p>Looking further into the initialization method, the <code class="docutils literal"><span class="pre">_iop.request_iop()</span></code> call instantiates an instance of an IOP on the specified pmod_id and loads the MicroBlaze executable (ALS_PROGRAM) into the instruction memory of the appropriate MicroBlaze.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">iop</span> <span class="o">=</span> <span class="n">request_iop</span><span class="p">(</span><span class="n">if_id</span><span class="p">,</span> <span class="n">PMOD_ALS_PROGRAM</span><span class="p">)</span>
</pre></div>
</div>
<p>An MMIO class is also instantiated to enable read and write to the shared memory.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">mmio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iop</span><span class="o">.</span><span class="n">mmio</span>
</pre></div>
</div>
<p>Finally, the iop.start() call pulls the IOP out of reset. After this, the IOP will be running the als.bin executable.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">iop</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="example-of-python-class-runtime-methods">
<h3>Example of Python Class Runtime Methods<a class="headerlink" href="#example-of-python-class-runtime-methods" title="Permalink to this headline">¶</a></h3>
<p>The read method in the Pmod_ALS class will simply read an ALS sample and return that value to the caller.  The following steps demonstrate a Python to MicroBlaze read transaction specfic to the ALS class.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>First, the command is written to the MicroBlaze shared memory using mmio.write(). In this case the value 0x3 represents a read command. This value is user defined in the Python code, and must match the value the C program running on the IOP expects for the same function.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">mmio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">iop_const</span><span class="o">.</span><span class="n">MAILBOX_OFFSET</span><span class="o">+</span>
                    <span class="n">iop_const</span><span class="o">.</span><span class="n">MAILBOX_PY2IOP_CMD_OFFSET</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>When the IOP is finished, it will write 0x0 to the command area. The Python code now uses mmio.read() to check if the command is still pending (in this case, when the 0x3 value is still present at the <code class="docutils literal"><span class="pre">CMD_OFFSET</span></code>).  While the command is pending, the Python class blocks.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mmio</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">iop_const</span><span class="o">.</span><span class="n">MAILBOX_OFFSET</span><span class="o">+</span>
                            <span class="n">iop_const</span><span class="o">.</span><span class="n">MAILBOX_PY2IOP_CMD_OFFSET</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Once the command is no longer 0x3, i.e. the acknowledge has been received, the result is read from the <code class="docutils literal"><span class="pre">DATA</span></code> area of the shared memory <code class="docutils literal"><span class="pre">MAILBOX_OFFSET</span></code> using <cite>mmio.read()</cite>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mmio</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">iop_const</span><span class="o">.</span><span class="n">MAILBOX_OFFSET</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice the iop_const values are used in these function calls, values that are predefined in <code class="docutils literal"><span class="pre">iop_const.py</span></code>.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Xilinx.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>